'''
Created on 29 Jan 2010

@author: Harry
'''
from copy import deepcopy
from django.db.models.query_utils import Q
#from django.utils.itercompat import is_iterable  #django buit in funciton returns true on strings!!! bad
from django.utils.encoding import smart_str, smart_unicode
from django.http import QueryDict
from pricing.models import *
from django.db.models.loading import get_model

#-------toolkit functions-----
def is_iterable(val):
    """returns true if val is proper iterable. (ie false for strings)"""
    return hasattr(val,'__iter__')

def get_iterator(query_dict):
    if type(query_dict) == QueryDict:
        return query_dict.iterlists()
    else:
        return query_dict.iteritems()


def DEPERECATED_de_unicode_dict(orig_dict={}):
    """function converts any unicode vals in a dictionary to normal strings
    returns a dictionary even if passed a queryset
    """
    nudict = deepcopy(dict(orig_dict))

    #lambda function tostring if unicode
    de_u = lambda x:(type(x)==type(u'')) and smart_str(x) or x #and/or trick, like ternary operator

    for key, val in nudict.items():
        del nudict[key]
        #if val is a list, apply to list
        if is_iterable(val):
            nudict[de_u(key)] = [de_u(v) for v in val]
        else:#de-u our val
            nudict[de_u(key)] = de_u(val)

    return nudict


def strip_dict_blanks(orig_dict={}):
    """ function strips blank entries from a dictionary
    returns a new dictionary, even if passed a queryset
    """
    nudict = deepcopy(dict(orig_dict))
    for key, val in nudict.items():
        if not val : del nudict[key] #if val is blank
        if is_iterable(val) and len(val)==1 and not val[0]: del nudict[key] #if val is a list containg just one empty element
    return nudict


#----model API specific functions-----

def column_verbose_names(model=Chamber_Contacts):
    """ returns a list of the raw field names for any model, for use eg in template iterators
    does not include id field
    currently only in use for contacts view. others use form method
    """
    #build list of column names from the fields
    column_names = [f.verbose_name for f in model._meta.fields]
    if 'id' in column_names: column_names.remove('id')
    return column_names


def modelOf(field_as_string):
    """ return the model class for a field"""
    #TODO: look at using generic django function  get_model?
    switch = {'chamber':Chamber,
              'fee_type':FeeType,
              'professional_type':ProfessionalType,
              'framework_panel':Panel,
              'panels':Panel, #nomenclature in barristers
              'level_of_court':Court,
              'type_of_work':WorkType,
              'seniority':Seniority,
              BN:Barrister,
              CD:Chamber_Contacts}
    if not field_as_string in switch.keys():
        tentative = get_model('pricing',field_as_string)
        if tentative: return tentative
        else: raise ValueError(str(field_as_string)+'not a dropdowns model')
    else: return switch[field_as_string] #wacky python switch analogy. howdya like that!?


def fieldOf(model,field_name):
    """returns the actual model field of a given name"""
    for f in model._meta.fields + model._meta.many_to_many:
        if f.name==field_name: return f
    raise ValueError('field %s not found in model %s'%(field_name,str(model)))

def _fieldname_recurse(model):
    if not hasattr(model,'_meta'):
        return []
    else:
        parent = super(type(model),model)
        my_fields = [f.name for f in model._meta.fields]
        my_fields += [f.name for f in model._meta.many_to_many]
        return _fieldname_recurse(parent)+ my_fields


def fieldNamesOf(model):
    """
    returns the field names of a model from _meta
    but also gets all its parents model's fields
    excludes back-end fields, eg 'id' or xxx_ptr
    """
    if not hasattr(model,'_meta'):
        raise ValueError('%s not a model'%str(model))
    all_fields = _fieldname_recurse(model)
    #all_fields = model._meta.get_all_field_names() - returns too many
    for f in all_fields:
        #remove back-end fields
        if f=='id' or f.endswith('_ptr'): all_fields.remove(f)
    return all_fields


def managerOf(manager_name):
    if not manager_name in VIEWNAMES: raise ValueError(str(manager_name)+' not a view')
    try: #custom model manager on Fee
        model_manager = Fee.typed_manager(manager_name)
    except KeyError: # or, a straight model's default manager, eg chamber_contacts or barrister
        model_manager = modelOf(manager_name).objects
    return model_manager


def managerNameOf(manager):
    for name in VIEWNAMES:
        if managerOf(name)==manager: return name
    return ''
    #if manager == Fee.objects: return ''
    #raise ValueError(str(manager)+' not a valid manager')


def verbose_name_of(field):
    if hasattr(field,'verbose_name'):
        if hasattr(field.verbose_name,'capitalize'):
            return field.verbose_name.capitalize()
        else:
            return field.verbose_name
    else:
        return smart_unicode(field)


def verbose_name_plural_of(field):
    if hasattr(field,'verbose_name_plural'):
        if hasattr(field.verbose_name_plural,'capitalize'):
            return field.verbose_name_plural.capitalize()
        else:
            return field.verbose_name_plural
    else:
        verb = verbose_name_of(field)
        return verb.endswith('s') and verb or verb +u's'


def add_joining_prefixes(query, joining_model_name=''):
    query_with_prefixes = {}
    for key,val in get_iterator(query):
        prefixed_key = '%s__%s' % (joining_model_name, key)
        query_with_prefixes[prefixed_key] = val
    return query_with_prefixes


def make_query_from_request(query_dict):
    if not query_dict:
        return Q()
    query = None
    for fieldname, choices in get_iterator(query_dict):
        if choices:
            this_field_query = None
            if not is_iterable(choices):
                this_field_query = Q(**{fieldname:choices})
            elif len(choices)==1 and choices[0]:
                this_field_query = Q(**{fieldname:choices[0]})
            else:
                for choice in choices:
                    new_query = Q(**{fieldname:choice})
                    if not this_field_query:
                        this_field_query = new_query
                    else:
                        this_field_query = this_field_query | new_query
            if not query:
                query = this_field_query
            else:
                query = query & this_field_query
    return query


def strip_form_prefixes(choices):
    fixed_dict = {}
    for fieldname, choices in get_iterator(choices):
        if fieldname.startswith('form-'):
            fixed_dict[fieldname[7:]] = choices
    return fixed_dict


def makeQQuery(query_dict, joining_model_name=''):
    """
    return a queryset for a particular set of choices
    optional_joining_model_name is needed if the query
    is being run against a different model from
    the fields defined in choices_dict
    for example, to look back up from chambers via fixed_fees
    """

    #add reference to eg fixed_fee
    if joining_model_name:
        query_dict = add_joining_prefixes(query_dict, joining_model_name)

    return make_query_from_request(query_dict)


def convert_dict_vals_to_lists(dict):
    """converts values of a dictionary to being lists (even if with one item). fixes multichoicey forms"""
    nudict = {}
    for key,val in dict:
        if is_iterable(val):
            nudict[key] = val
        else:
            nudict[key] = [val]
    return nudict


def uniq(seq, idfun=None):
    """order preserving version of set(seq)"""
    if idfun is None:
        def idfun(x): return x
    seen = {}
    result = []
    for item in seq:
        marker = idfun(item)
        if marker in seen: continue
        seen[marker] = 1
        result.append(item)
    return result
