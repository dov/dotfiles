'''
Created on 1 Jan 2010

@author: Harry. based on http://snippets.dzone.com/posts/show/7410
'''
#===============================================================================
#---imports
#===============================================================================
from __future__ import with_statement
from django.core.exceptions import ObjectDoesNotExist, MultipleObjectsReturned
import traceback
from django.utils.encoding import smart_str
import os,sys
from xlrd import open_workbook, XL_CELL_NUMBER #@UnresolvedImport
from _mysql_exceptions import IntegrityError


#===============================================================================
#---global constants (mostly to do with method statements import
#===============================================================================
FIRM_NAME_ROW = 1
FIRM_NAME_COL = 2
PANEL_ROW = 1
PANEL_COLUMN = 7

FIRST_STAGE_ROW = 6
LAST_STAGE_ROW = 32
STAGE_DESC_COL = 1
SENIORITY_COL = 2
HOURS_COL = 3
RATE_COL = 4
DISBURSEMENTS_COL = 5
SUBTOTALS_COL = 6
TOTAL_COL = 6
TOTAL_ROW = 3

COMMENTS_COLUMN = 7

#===============================================================================
# #------------preliminary functions----------------
#===============================================================================

def drop_app_tables(app_name):
    """
    drop all the database tables for an app, based on the app name
    (all tables names should be prefixed by the app name)
    """
    from django.db import connection

    print '===START DROPPING TABLES IN DATABASE==='
    tables = connection.introspection.table_names() #@UndefinedVariable

    for t in tables:
        if not t.find(app_name)==-1:
            cursor = connection.cursor() #@UndefinedVariable
            cursor.execute("DROP TABLE %s"%t)
            print 'dropped table',t
    print '===END DROPPING TABLES==='

def syncdb(settings_module):
    """
    will run syncdb against a given settings module
    """
    import subprocess
    settings_folder = os.path.dirname(settings_module.__file__)
    if not os.path.isdir(settings_folder):
        print 'error, not a folder: ', settings_folder
        sys.exit()

    syncdb = subprocess.Popen(['python',os.path.join(settings_folder,'manage.py'),'syncdb','--settings='+settings_module.__name__])

    resp_code = syncdb.wait()
    if resp_code:
        print 'error during syncdb'
        sys.exit()


def dump_fixtures(settings_module):
    """
    will run dumpdata against a given settings module
    """
    import subprocess
    settings_folder = os.path.dirname(settings_module.__file__)
    if not os.path.isdir(settings_folder):
        print 'error, not a folder: ', settings_folder
        sys.exit()

    with open('initial_data.json','w') as fixture:
        process = subprocess.Popen(['python',
            os.path.join(settings_folder,'manage.py'),
            'dumpdata',
            '--settings='+settings_module.__name__,
            'pricing','auth'],
            stdout = fixture)
        resp_code = process.wait()
        if resp_code:
            print 'error during dumpdata op'
            sys.exit()


def setup_django_environment(settings_module_name='settings', settings_module_folder=''):
    """
    setup django environment based on file's directory.
    change settings file name to settings_nwlc if necessary...
    """
    import sys
    import os
    if not settings_module_folder:
        current_path = os.path.dirname(__file__)
        if not current_path:
            current_path = os.getcwd()
            print 'warning - executing from current working directory',current_path
        settings_module_folder = os.path.split(current_path)[0]
    if not os.path.isdir(settings_module_folder):
        print 'couldnt find settings folder at ',settings_module_folder
        sys.exit()
    sys.path.append(settings_module_folder)
    try:
        exec('import %s as settings'%settings_module_name)
    except ImportError:
        print 'could not find settings file in', settings_module_folder
        traceback.print_exc()
        sys.exit()

    from django.core.management import setup_environ
    setup_environ(settings) #@UndefinedVariable
    return settings #@UndefinedVariable

#===============================================================================
#--- main csv import functions
#===============================================================================

def _checkModelAgainstCSV(model,csv):
    """ checks a model's fields against the first row of a csv reader"""
    modelfields = model._meta.fields
    modelfields = [f.name for f in modelfields] #omg it took me a while to figure out how to do this but python is AWESOME

    mismatch = False  #not quite happy with this way of doing things, but it works
    for cell in csv :
        if not(cell in modelfields) :
            mismatch = True
            print 'error - column mismatch. model '+str(model)+'  csv_column='+cell

    if mismatch:
        return False
    else:
        return True


def import_from_csvs(rootpath, just_params=False):
    """ runs main csv import against a source path."""
    try:
        from pricing.models import *
    except:
        print 'error importing pricing models. check django envt.'
        traceback.print_exc()

    import csv  #import csv format handler

    #nested list links filenames to appropriate model class
    tables_dict = [['lawyer_types.csv', ProfessionalType],
                   ['panels.csv', Panel],
                   ['courts.csv', Court],
                   ['panel_courts.csv', PanelCourts],
                   ['feetypes.csv', FeeType],
                   ['worktypes.csv', WorkType],
                   ['seniorities.csv', Seniority],
                   ['chambers.csv', Chamber],
                   ['chamber_contacts.csv', Chamber_Contacts],
                   ['barristers.csv',Barrister],
                   ['barrister_panels.csv',Barrister_Panels],
                   ['all_fees.csv',Fee],]
    #despite its name, it's not a dictionary (it was at first but that caused problems with its not being sorted and foreign key integrity)
    if just_params:
        tables_dict = tables_dict[:-4]
    #import files one by one
    for table in tables_dict:
        filename = os.path.join(rootpath,table[0]) #first item in list is file name
        model = table[1] #second item is the appropriate model class

        #open csv dictionary reader
        reader = csv.DictReader(open(filename,'U'), dialect='excel')
        reader.next() #initialises reader

        csv_columns = reader.fieldnames
        counter = 0
        if _checkModelAgainstCSV(model, csv_columns):
            #need to reload the reader cos we skipped a line during initialisation above
            reader = csv.DictReader(open(filename), dialect='excel')
            #now iterate thru the rows
            for dict in reader:
                new = model() #empty item for the current model
                for key,val in dict.items():
                    try:
                        if not(val==""):#avoid any blanks...
                            setattr(new,key,val) #used instead of new.key = val cos of runtimey isssues.  that took me a while to figure out!
                    except ValueError:
                        #occurs when we attempt to input an item that should be a foreign key
                        setattr(new,key+"_id",val)#ugly fix, but it works
                #and finally, save it to the database.
                try:
                    new.save()
                    counter+=1
                    #eval("model.objects.get_or_create("+init_string+")")
                except:
                    print '\nerror in %s, record=%s,\n'%(filename,new)
                    for key,val in dict.items():
                        print 'key=%s val=%s'%(key,val)
                    traceback.print_exc()
                    sys.exit()
            print 'file %s importer %d records' %(filename,counter)
        else:
            print 'mismatched columns in ' + filename
            sys.exit()
    print 'end main csv pricing data import'


def buildTemplates(templates_file=None):
    """
    function builds master template models, including child stages
    """
    if not templates_file:
        print ' need templates file'
        sys.exit()

    try:
        from pricing.models import *
    except:
        print 'error importing pricing models. check django envt.'
        traceback.print_exc()

    wb = open_workbook(templates_file)
    statements_sheet = wb.sheet_by_name('statements')
    stages_sheet = wb.sheet_by_name('stages')

    for row in range(1, statements_sheet.nrows):
        id_cell = statements_sheet.cell(row,0)
        if id_cell.value and id_cell.ctype == XL_CELL_NUMBER:
            ms = MethodStatementTemplate()
            ms.id = id_cell.value
            ms.name = statements_sheet.cell(row,2).value
            ms.description = statements_sheet.cell(row,3).value
            panel_cell = statements_sheet.cell(row,1)
            if panel_cell.ctype==XL_CELL_NUMBER:
                ms.framework_panel = Panel.objects.get(pk=int(panel_cell.value))
                ms.save()
                print 'Method Statement Template',ms.name,'imported'

    for row in range(1, stages_sheet.nrows):
        id_cell = stages_sheet.cell(row,0)
        if id_cell.value and id_cell.ctype == XL_CELL_NUMBER:
            stg = MethodStatementTemplateStage()
            stg.id = id_cell.value
            stg.name = stages_sheet.cell(row,3).value
            parent_id = stages_sheet.cell(row,1).value
            stg.parent = MethodStatementTemplate.objects.get(pk=int(parent_id))
            stg.number = stages_sheet.cell(row,2).value
            stg.save()
            print 'Method Statement Stage',stg.name,'imported'


def get_object_by_splitting_name(model, name, additional_params={}):
    split_name = name.split(' ')
    for r in range(len(split_name),0,-1):
        try:
            short_name = ' '.join(split_name[:r])
            print 'trying', short_name
            return model.objects.get(name__icontains=short_name, **additional_params)
            break
        except (ObjectDoesNotExist, MultipleObjectsReturned):
            continue
    raise ValueError(
            "couldn't find an object of type %s called %s with params %s"
            %( model, name, additional_params))


def get_chamber_for(chamber_name):
    try:
        from pricing.models import Chamber
    except:
        print 'error importing pricing models. check django envt.'
    chamber = None
    try:
        chamber = Chamber.objects.get(name=chamber_name)
    except ObjectDoesNotExist:
        get_object_by_splitting_name(Chamber, chamber_name)
    return chamber


def _buildMethodStatementFromSheet(s):
    """ build parent method statement from excel sheet"""

    try:
        from pricing.models import (
                Fee, MethodStatement, MethodStatementTemplate, SavedFeeCalculation,
                Panel, User,
        )
    except:
        print 'error importing pricing models. check django envt.'
        traceback.print_exc()

    firm_cell = s.cell(FIRM_NAME_ROW,FIRM_NAME_COL)
    panel_cell = s.cell(PANEL_ROW,PANEL_COLUMN)
    total_cell = s.cell(TOTAL_ROW,TOTAL_COL)
    if total_cell.ctype==XL_CELL_NUMBER and total_cell.value>0 :
        if s.name == 'education':
            panel = Panel.objects.get(name='Education', professional_type__id=2)
        else:
            panel = Panel.objects.get(name=panel_cell.value, professional_type__id=2)
        chamber = get_chamber_for(firm_cell.value)
        print 'firm name:',chamber, 'panel:',panel, 'total:', total_cell.value
        #check we find a match for this chamber & panel
        matches = Fee.objects.filter(chamber=chamber,framework_panel=panel)
        if len(matches)<1: return False

        #build fee calculation
        feecalc = SavedFeeCalculation()
        feecalc.chamber = chamber
        feecalc.overall_total = total_cell.value
        feecalc.name = 'for method statement - %s, %s'%(chamber,panel)
        feecalc.author = User.objects.all()[0]  #default user
        feecalc.visible = False

        #assign to method statement
        ms = MethodStatement()
        ms.template = MethodStatementTemplate.objects.get(framework_panel=panel)
        ms.quoted_total = total_cell.value
        feecalc.save()
        ms.fee_calculation = feecalc
        ms.save()
        return ms
    else:
        return False


def get_template_stage_for(stage_name, ms):
    assert stage_name[2] == ' '
    stage_name = stage_name[3:].strip()
    try:
        from pricing.models import (MethodStatementTemplateStage)
    except:
        print 'error importing pricing models. check django envt.'
    try:
        return MethodStatementTemplateStage.objects.get(
            name=stage_name,
            parent__framework_panel=ms.template.framework_panel
        )
    except ObjectDoesNotExist:
        return get_object_by_splitting_name(
                MethodStatementTemplateStage, stage_name, additional_params=dict(
                    parent__framework_panel=ms.template.framework_panel)
        )





def _buildMethodStageFromSheetRow(s,row,ms):
    try:
        from pricing.models import MethodStatementStage
    except:
        print 'error importing pricing models. check django envt.'
        traceback.print_exc()

    mss = MethodStatementStage()

    stage_cell=s.cell(row,STAGE_DESC_COL)
    #stage_desc = stage_cell.value[3:]
    subtotal_cell = s.cell(row,SUBTOTALS_COL)
    mss.parent = ms
    stage_template = get_template_stage_for(stage_cell.value, ms)
    mss.stage = stage_template
    mss.quoted_subtotal = subtotal_cell.ctype==XL_CELL_NUMBER and subtotal_cell.value or 0
    #TODO: check subtotal adds up??
    #print '\n=========stage:',mss.stage.number,'/',mss.stage.name,'subtotal:',mss.subtotal,'\n'
    mss.save()
    return mss


def _buildMethodLineFromRow(s,row,mss):
    try:
        from pricing.models import (
                MethodStatementLine, SavedFeeCalculatorLine, Seniority, Fee, WorkType
        )
    except:
        print 'error importing pricing models. check django envt.'
        traceback.print_exc()

    msl = MethodStatementLine()
    msl.stage = mss

    disb_cell = s.cell(row,DISBURSEMENTS_COL)
    msl.disbursements = disb_cell.ctype == XL_CELL_NUMBER and disb_cell.value or 0

    comments_cell = s.cell(row,COMMENTS_COLUMN)
    msl.comments = smart_str(comments_cell.value)
    msl.comments = msl.comments.replace('\xEF\x82\xA7','*') #fixes some encoding issues
    msl.comments = msl.comments.replace('\xEF\x81\xB6','*') #fixes some encoding issues
    try:
        fcl = SavedFeeCalculatorLine()
        fcl.parent = mss.parent.fee_calculation
        seniority_cell = s.cell(row,SENIORITY_COL)
        seniority = Seniority.objects.get(name__startswith=seniority_cell.value[:1])
        hours_cell = s.cell(row,HOURS_COL)
        fcl.quantity = hours_cell.ctype == XL_CELL_NUMBER and hours_cell.value or 0
        fee = Fee.objects.get(
                seniority=seniority,
                chamber=mss.parent.fee_calculation.chamber,
                framework_panel = mss.stage.parent.framework_panel,
                type_of_work = WorkType.objects.get(name__icontains='General Advice')
        )
        fcl.fee = fee
        fcl.save()
        msl.feecalc_line=fcl
    except (ObjectDoesNotExist, MultipleObjectsReturned):
        print "WARNING couldn't find a fee for",mss.parent.fee_calculation.chamber,mss.stage.parent.framework_panel,seniority
        raise ValueError

    rate_cell = s.cell(row,RATE_COL)
    rate_val = rate_cell.ctype == XL_CELL_NUMBER and rate_cell.value or 0
    msl.quoted_rate = rate_val
    msl.quoted_fee = rate_val * msl.feecalc_line.quantity

    msl.save()
    return msl


def processResponseFiles(SOURCE_FOLDER):
    all_files = os.listdir(SOURCE_FOLDER)
    total_files_processed = 0
    for f in all_files:
        try:
            wb = open_workbook(os.path.join(SOURCE_FOLDER,f))
        except:
            print '=============file',f,'skipped=================='
            continue
        try:
            if f.find('flattening')>0: continue #not a panel listing
            print '\n\n\nprocessing file',f,'\n'
            for s in wb.sheets():
                skip_sheets_with =['summary', 'INSTRUCTIONS', 'hourly_fees', 'Sheet', 'parameters']
                if all(n not in s.name for n in skip_sheets_with):
                    print '\n=================\nprocessing sheet:',s.name,'\n'
                    #build parent method statement
                    ms = _buildMethodStatementFromSheet(s)
                    #total_check = 0
                    if ms:
                        for row in range(FIRST_STAGE_ROW,LAST_STAGE_ROW):

                            if row%3==0: #rows that are multiples of 3 are stage bounaries
                                try:
                                    stage_cell=s.cell(row,STAGE_DESC_COL)
                                except IndexError:
                                    if row > FIRST_STAGE_ROW: break
                                    else: raise
                                if not stage_cell.value: break #exit for loop when we run out of stages
                                #build parent methodstage
                                mss = _buildMethodStageFromSheetRow(s,row,ms)
                            #build line items
                            _buildMethodLineFromRow(s,row,mss)

                        #done processing rows.  update total in fee calculation
                        ms.fee_calculation.save()
            total_files_processed+=1
        except:
            traceback.print_exc()
            print '\n================ERRROR=========\nfile:',f
            print 'last sheet',s.name
            print 'last row',row
            sys.exit()

    print 'processed',total_files_processed,'files'



def anonymise():
    # get all chambers and firms
    from pricing.models import Fee, Chamber, Chamber_Contacts
    all_chambers = Chamber_Contacts.objects.filter(type__icontains='chamber')
    all_firms = Chamber_Contacts.objects.filter(type__icontains='firm')

    #some random names
    partial_chamber_names=['Peregrin',
                       'Boatyard',
                       'Princes',
                       'Jacks chair pitch',
                       'Stutton',
                       'Hidden',
                       'New Old',
                       'Baker',
                       'Old ',
                       'Middle',
                       'Polished',
                       'Plinth'
                       ]
    partial_firm_names = ['Tatterstalls',
                      'Turtle',
                      'Spaulding',
                      'Chase',
                      'Horlicks',
                      'Amber',
                      'Winning',
                      'Happy',
                      'Wimbledon',
                      'Recursive',
                      'Hudson',
                      'Hicks',
                      'Vasquez',
                      ]

    #combine them up randomly:
    import random
    new_chamber_names = []
    while len(new_chamber_names)<len(all_chambers):
        new_name = str(random.choice(range(25))) +' '+ random.choice(partial_chamber_names) +' '+ random.choice(['St','Lane','Road'])
        if new_name not in new_chamber_names:
            new_chamber_names.append(new_name)
    print new_chamber_names
    new_firm_names = []
    while len(new_firm_names)<len(all_firms):
        new_name = random.choice(partial_firm_names) +' '+ random.choice(partial_firm_names)+ ' '+ random.choice(['Partners','LLP','Smith','Jones'])
        if new_name not in new_firm_names:
            new_firm_names.append(new_name)
    print new_firm_names

    #now process chambers - need to change info for 3 models:
    #Chamber, Organisation and Chamber_Contacts
    i=0
    for cc in all_chambers:
        try:
            c = cc.chamber
            c.name = cc.name = new_chamber_names[i]
            cc.email_general = 'anonym@ous.com'
            cc.website = 'wwww.website.com'
            cc.address = cc.name + ', ' + str(cc.city)
            c.save() #save to CHamber model + table
            cc.save() #save to Organisation / Chamber_Contacts table
            i=i+1
            print c, 'chamber name changed'
        except:
            print 'error amending chamber',c
            traceback.print_exc()
            sys.exit()

    i=0
    for cc in all_firms:
        try:
            c = cc.chamber
            c.name = cc.name = new_firm_names[i]
            cc.email_general = 'anonym@ous.com'
            cc.website = 'wwww.website.com'
            cc.address = cc.name + ', ' + str(cc.city)
            c.save() #save to CHamber model + table
            cc.save() #save to Organisation / Chamber_Contacts table
            i=i+1
            print c, 'firm name changed'
        except IntegrityError:
            pass
        except:
            print 'error amending firm',c
            traceback.print_exc()
            sys.exit()

    #now change prices
    for c in Chamber.objects.all():
        factor = random.uniform(0.5,3)
        fees = Fee.objects.filter(chamber=c)
        for f in fees:
            f.fee = float(int(100*(f.fee * factor)))/100  #rounds to 2 dp.
            f.save()
        print c,'fees changed'


def add_user_accounts():
    from django.contrib.auth.models import Group, User

    for groupname in ['Client', 'Legal']:
        g = Group()
        g.name = groupname
        try:
            g.save()
        except:
            print 'already got group', g.name

    current_legal_users = Group.objects.get(name='Legal').user_set.all()
    current_legal_users.delete()

    su = User()
    su.username = 'super'
    su.set_password('duper')
    su.is_superuser = True
    su.is_staff = True
    try:
        su.save()
    except:
        print 'already got superuser'

    from pricing.models import Chamber
    legal_group = Group.objects.get(name='Legal')
    for chamber in Chamber.objects.all():
        u = User()
        chamber_name_words = chamber.name.split()
        if len(chamber_name_words)<3:
            username = ''.join(chamber_name_words).lower()
        else:
            try:
                int(chamber_name_words[0][0])
                username = chamber_name_words[0]
                chamber_name_words = chamber_name_words[1:]
            except:
                username = ''
            username +=''.join([word[:1] for word in chamber_name_words]).lower()

        u.username = username
        password = User.objects.make_random_password()
        u.set_password(password)
        try:
            u.save()
            u.groups.add(legal_group)
            u.save()
            chamber.user = u
            chamber.save()
            print 'Chamber,%s,Username,%s,Password,%s'%(chamber.name,u.username,password)
        except:
            print 'user %s already exists'%(u.username,)


#===============================================================================
# main exec function:
#===============================================================================
def import_for(settings_module_name='settings',
               settings_module_folder = '',
               source_data_folder='',
               just_params=False,
               add_users=False,
               do_method_statments=False):
    """
    main importer function. parameters:
    settings_module_name: default='settings', could be 'settings_nwlc' if different settings.py
    settings_module_folder: defaults to the parent folder of calling module
    source_data_folder: defaults to calling module folder plus /nwlc_specifc/source_data/
    do_method_statments: true of false, default=True):
    """

    #setup environment
    settings = setup_django_environment(settings_module_name, settings_module_folder)
    try:
        from pricing.models import Fee
    except:
        print 'error importing pricing models. check django envt.'
        traceback.print_exc()

    #find folders to import from
    if source_data_folder:
        if not os.path.exists(source_data_folder):
            print 'error %s - no such folder'%source_data_folder
            sys.exit()

    #rebuild db tables - first drop
    drop_app_tables('pricing')
    #then run syncdb
    syncdb(settings)

    #main csv import
    import_from_csvs(source_data_folder, just_params)

    #remove blank fees
    blank_fees = Fee.objects.filter(fee=None)
    print blank_fees.count(), 'blank fees found, deleting...'
    blank_fees.delete()

    #and do method statements if needed
    if do_method_statments:
        templates_file = os.path.join(source_data_folder,'ms_templates_flattening.xls')
        buildTemplates(templates_file)
        processResponseFiles(source_data_folder)

    if add_users:
        add_user_accounts()

    print 'dumping fixtures'
    dump_fixtures(settings)

    print 'all done'


#===============================================================================
#-----------------END FUNTIONS-----------
#===============================================================================


#------exec if run on its own----
if __name__=='__main__':
    import_for('settings','','',True)
    sys.exit()
