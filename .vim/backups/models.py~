""" models definiton. also includes forms, and some key functions for, eg, forms dropdown list extraction
"""


from django.db import models
from django.contrib.auth.models import User, Group
from django.utils.translation import ugettext_lazy as _ #for translations/labels - like verbose_name
from datetime import datetime


#------------------------------------------------------------------------------ 
#constants
#------------------------------------------------------------------------------ 

ORG_TYPES = (
        ('LA', 'Local Authority'),
        ('C', 'Chambers'),
        ('L', 'Law Firm'),
)

BARRISTERS = 1
SOLICITORS = 2

ORG_CORRESP = {BARRISTERS:'C',SOLICITORS:'L'}
TYPE_CORRESP = {BARRISTERS:"Barristers' Chamber",SOLICITORS:"Solicitors' Firm"}

#constants for view/manager names
FF = 'fixed_fees'
HF = 'hourly_fees'
GF = 'general_fees'
BFF = 'barristers_fixed_fees'
BHF = 'barristers_hourly_fees'
BF = 'barristers_fees'
SF =  'solicitors_fees'

BN = 'barristers_names'
CD = 'contacts'

VIEWNAMES = [FF,HF,GF,BFF,BHF,BF,SF,BN,CD]

#===============================================================================
#==================custom managers and querysets===================== 
#===============================================================================


class CustomisableManager(models.Manager):
    """custom manager for a particular fee type"""
    def __init__(self, verbose_name, model, filters_dict):
        """parameter=field to filter on, values may be a list"""
        self.verbose_name = verbose_name
        self.model = model
        self.filters_dict = {}
        self.add_filter(filters_dict)
        #super(self.__class__, self).__init__()


    def add_filter(self, filters_dict):
        #make all filter choices into lists
        #and add __in to all parameters
        for k,v in filters_dict.items():
            if not k.endswith('__in'):
                del filters_dict[k]
                k=k+'__in'
            if not hasattr(v,'__iter__'):
                v=[v]
            filters_dict[k]=v
        self.filters_dict.update(filters_dict)


    def get_query_set(self):
        """returns the normal queryset with the appropriate parameter filtered"""
        return self.model.objects.filter(**self.filters_dict)



class MyForeignKey(models.ForeignKey):
    """v simple foreign key adds verbose name from model"""
    def __init__(self, to_model, *args, **kwargs):
        if hasattr(to_model, 'VERBOSE_NAME'):
            kwargs['verbose_name'] = to_model.VERBOSE_NAME
        ForeignKey.__init__(self, to_model, *args, **kwargs)


#===============================================================================
#=========================== data models ===================================
#===============================================================================

# first the 'reference' / 'parameter' tables, which only have one "real" field
# each has an integer (non-auto) primary key, for facilitating imports...
# all subclass an abstract 'Parameter' class
class Parameter(models.Model):
    """abstract base class for simple parameter tables, eg framework panel, fee type..."""
    name = models.CharField(max_length=100)  #name/description

    def __unicode__(self):
        return self.name

    class Meta:
        ordering = ['name']
        abstract = True



class ProfessionalType(Parameter):
    VERBOSE_NAME = 'Lawyer Type'



class TypedParameter(Parameter):
    """abstract class for parameters that are typed to barristers or solicitors"""
    professional_type = models.ForeignKey(ProfessionalType,default=BARRISTERS) #barristers or solicitors

    class Meta:
        ordering = ['professional_type','name']
        abstract = True



class Panel(TypedParameter):
    VERBOSE_NAME = 'Framework Panel'



class Court(TypedParameter):
    VERBOSE_NAME = 'Level of Court'
    panels = models.ManyToManyField(Panel, through='PanelCourts')



class PanelCourts(models.Model):
    panel = models.ForeignKey(Panel)
    court = models.ForeignKey(Court)



class FeeType(TypedParameter):
    VERBOSE_NAME = 'Fee Type'
    #---constants---
    FIXED = 1
    HOURLY = 2
    GENERAL = SOLICITORS = 3



class WorkType(TypedParameter):
    VERBOSE_NAME = 'Type of Work'

    definition = models.TextField(blank=True, null=True) #definitions, only for fixed fees
    fee_type = models.ForeignKey(FeeType)
    sort_order = models.IntegerField(blank=True, null=True)

    class Meta:
        ordering = ['professional_type','sort_order']



class Seniority(TypedParameter):
    VERBOSE_NAME = 'Seniority'
    sort_order = models.IntegerField() #used to sort seniorities in a sensible non-alpha way
    min = models.IntegerField(blank=True, null=True) #min no of years for this seniority
    max = models.IntegerField(blank=True, null=True) #max no of years for this seniority

    class Meta(Parameter.Meta):
        ordering = ['sort_order'] #overruled



class Chamber(TypedParameter):
    VERBOSE_NAME = 'Chamber/Firm'
    user = models.ForeignKey(User, blank=True, null=True)



class Barrister(models.Model):
    """
    barristers has more data in - some barristers may work for 2 different firms in which case there are 2 entries
    this happens v rarely, so normalisation impact minimal
    also some barristers have the same name!
    """

    #---constants---
    YES = 1
    NO = 0
    QC_CHOICES = ((YES, "Yes"), (NO, "No"),)
    VERBOSE_NAME = 'Barrister'

    #---custom managers---
    #objects=BarristerManager()

    #---fields---
    #id = models.IntegerField(primary_key=True)
    last_name = models.CharField(_('Last Name'),max_length=200)
    first_name = models.CharField(_('First Name'), max_length=200)
    full_name = models.CharField(_('Full Name'), max_length=410, editable=False, blank=True)
    chamber = MyForeignKey(Chamber, verbose_name=Chamber.VERBOSE_NAME)
    is_qc = models.IntegerField(choices=QC_CHOICES, verbose_name='Is QC?')  #this is 1 or 0 in my csv file...
    year_of_call = models.IntegerField()
    seniority = MyForeignKey(Seniority, editable=False, blank=True)
    panels = models.ManyToManyField(Panel, through='Barrister_Panels', verbose_name='Framework Panels')
    #many-to-many relationship to go via intermediary table
    #django could do this automatically, but is safer for me to specify for importing purposes

    class Meta:#
        ordering = ['last_name']
        unique_together = ('first_name','last_name','chamber')

    def __unicode__(self):
        return self.full_name

    #---calculated fields functions---
    def _full_name(self):
        """return lastname,firstname plus qc as appropriate."""
        composite_name = self.last_name + ", " + self.first_name
        if self.is_qc :
            composite_name += " (QC)"
        return composite_name

    def _seniority(self):
        """ derive seniority from years of call"""
        if not self.year_of_call:
            return None

        years_since_call = datetime.today().year - self.year_of_call

        #iterate thru seniorities, finding ones that match the max/min years since call. 
        #check also if QC...
        if self.is_qc:
            return Seniority.objects.filter(name__icontains='queen')[0]
        else:
            return Seniority.objects.filter(
                    min__lte=years_since_call,
                    max__gte=years_since_call).exclude(name__icontains='queen')[0]


    #override save method to fill in calculated field values     
    def save(self, *args, **kwargs):
        #coerce year of call and qc to ints for logic to work
        try:
            self.year_of_call = int(self.year_of_call)
            self.is_qc = int(self.is_qc)
        except:
            raise ValueError('non-int value given for year of call or is_qc')
        #call methods to define calc fields
        self.full_name = self._full_name()
        self.seniority = self._seniority()
        #and call super save.
        super(Barrister, self).save(*args, **kwargs)


    #---custom properties---    
    @property
    def panels_as_text(self):
        """return list of panels separated by commas"""
        return ', '.join([str(p) for p in self.panels.distinct()])


    @property
    def panels_as_br_list(self):
        return '<br />'.join([str(p) for p in self.panels.distinct()])


    def set_panels(self, panels):
        Barrister_Panels.objects.filter(barrister=self).delete()
        for panel in panels:
            relation = Barrister_Panels()
            relation.barrister = self
            relation.panel = panel
            relation.save()


    @property
    def is_qc_verbose(self):
        return dict(self.QC_CHOICES)[self.is_qc]



class Barrister_Panels(models.Model):
    barrister = models.ForeignKey(Barrister)
    panel = models.ForeignKey(Panel)

    def __unicode__(self):
        return self.barrister + ' - ' + self.panel



#===============================================================================
# more complex tables
#===============================================================================

class Organisation(models.Model):
    """
    An organisation can be a Local Authority, a Chambers or a Law Firm
    Barrisers are part of an organisation type Chambers
    Lawyers are part of an organisation Law Firm
    This is subclassed by chamber_contacts, for additional info
    """

    organisation_type = models.CharField(_('Organisation Type'), max_length=2, choices=ORG_TYPES, default='L' )
    name = models.CharField(_('Organisation Name'), max_length=50, unique=True)
    email_general = models.EmailField(_('Email (General Enquiries)'))
    address = models.CharField(_('Address'), max_length=1000)
    city = models.CharField(_('City'), max_length=200, blank=True, null=True)#optional field, used in nwlc
    postcode = models.CharField(_('Postcode'), max_length=200)
    telephone = models.CharField(_('Telephone'), max_length=200)
    website = models.URLField(_('Website'), blank=True, null=True)


    def __unicode__(self):
        return self.name

    class Meta:
        ordering = ['name']

    def is_localauth(self):
        """true if is a Local Authority"""
        return self.organisation_type == 'LA'

    def is_legal(self):
        """true if is a barristers chambers or a law firm"""
        return self.organisation_type == 'C' or self.organisation_type == "L"

    def _organisation_type_verbose(self):
        return dict(ORG_TYPES)[self.organisation_type]
    organisation_type_verbose = property(_organisation_type_verbose)



#chambers have some additional info    
class Chamber_Contacts(Organisation):
    """
    Chambers+ Firms have additional contact info, eg an FK link to chamber model
    """
    type = models.CharField(max_length=200, blank=True, null=True)

    chamber = models.ForeignKey(Chamber)
    fax = models.CharField(_('Fax'), max_length=200)
    tender_contact_name = models.CharField(_('Database Contact Name'), max_length=200)
    tender_contact_ddi_number = models.CharField(_('Database Contact Direct Line'), max_length=200)
    tender_contact_email = models.CharField(_('Database Contact Email'), max_length=200)

    class Meta:#
        ordering = ['chamber']

    def __unicode__(self):
        return self.email_general


    def save(self, *args, **kwargs):
        """populates 'name' and 'type' fields of parent class"""
        if self.chamber and self.chamber.name:
            self.name = self.chamber.name
            self.organisation_type = ORG_CORRESP[self.chamber.professional_type.id]
            #this means we could remove 'type' from csv imports...
            self.type = str(self.chamber.professional_type)

        super(Chamber_Contacts, self).save(*args, **kwargs)

#===============================================================================
# Fee parameter abstract models
# these are in a slightly strange structure to allow for
# ordering of fields...
#===============================================================================

class JustChamber(models.Model):
    """ abstract class with chamber"""
    chamber = MyForeignKey(Chamber)
    class Meta:
        abstract = True

class JustTypes(models.Model):
    """ abstract class with just 'type' fee params"""
    fee_type = MyForeignKey(FeeType)
    professional_type = MyForeignKey(ProfessionalType)
    class Meta:
        abstract = True

class RestOfFeeParameters(models.Model):
    """abstract class with other fee parameters"""
    #---fields---
    framework_panel = MyForeignKey(Panel)
    level_of_court = MyForeignKey(Court)
    type_of_work = MyForeignKey(WorkType)
    seniority = MyForeignKey(Seniority)
    class Meta:
        abstract = True

class FeeParametersNoChamber(JustTypes,RestOfFeeParameters):
    """abstract class contains basic fee parameters"""
    class Meta:
        abstract = True

class FeeParameters(JustTypes, JustChamber, RestOfFeeParameters):
    """ abstract class, containg all fee parameters"""
    class Meta:
        abstract = True

#now the main fees model.
class Fee(FeeParameters):

    #---additional fields---
    id = models.AutoField(primary_key=True)
    fee = models.FloatField(blank=True, null=True)#blank allows null values = "n/a" in current spreadsheet


    #---managers---
    objects = models.Manager()

    @classmethod
    def typed_manager(cls, manager_name):
        all_fees = CustomisableManager('Fixed Fees', cls, {})
        fixed_fees = CustomisableManager('Fixed Fees', cls, {'fee_type':FeeType.FIXED})
        hourly_fees = CustomisableManager('Hourly Fees', cls, {'fee_type':FeeType.HOURLY})
        general_fees = CustomisableManager('General Advice Fees', cls, {'fee_type':FeeType.GENERAL})
        barristers_fees = CustomisableManager('Barristers Fees', cls, {'professional_type':BARRISTERS})
        solicitors_fees = CustomisableManager('Solicitors Fees', cls, {'professional_type':SOLICITORS})
        barristers_fixed_fees = CustomisableManager('Barristers Fixed Fees', cls, {'professional_type':BARRISTERS, 'fee_type':FeeType.FIXED})
        barristers_hourly_fees = CustomisableManager('Barristers Hourly Fees', cls, {'professional_type':BARRISTERS, 'fee_type':FeeType.HOURLY})
        lookup = {
            0:all_fees,
            FF:fixed_fees,
            HF:hourly_fees,
            GF:general_fees,
            BF:barristers_fees,
            SF:solicitors_fees,
            BFF:barristers_fixed_fees,
            BHF:barristers_hourly_fees,
        }
        return lookup[manager_name]

    #---other bits n pieces---        
    class Meta:#
        ordering = ['framework_panel', 'chamber']
        #unique together constraint prevents duplicate fees at database level...
        unique_together = (
                'chamber',
                'professional_type',
                'fee_type',
                'framework_panel',
                'level_of_court',
                'type_of_work',
                'seniority'
        )


    def __unicode__(self):
        if self.fee:
            try:
                return "%s / %s / %s / %s /%s /%s : %.2f" % (self.chamber, self.fee_type, self.framework_panel, self.level_of_court, self.type_of_work, self.seniority, self.fee)
            except TypeError:
                #fee is non-float
                return "%s / %s / %s / %s /%s /%s : %s" % (self.chamber, self.fee_type, self.framework_panel, self.level_of_court, self.type_of_work, self.seniority, str(self.fee))
        else:
            return "%s / %s / %s / %s /%s /%s : N/A" % (self.chamber, self.fee_type, self.framework_panel, self.level_of_court, self.type_of_work, self.seniority)


FEE_PARAMETER_NAMES = [f.name for f in FeeParameters._meta.fields if type(f)==MyForeignKey]

#-----------FEE CALCULATOR AND COMPARATOR-------------
class SavedFeeComparison(models.Model):
    """ parent class, containing header info from fee comp."""
    name = models.CharField(max_length=500)
    author = models.ForeignKey(User)
    allowed_groups = models.ManyToManyField(Group, blank=True)
    #fee_calculations = models.ManyToManyField(SavedFeeCalculation, blank=True, editable=False) 
    chambers = models.ManyToManyField(Chamber, blank=True, editable=False)

    def __unicode__(self):
        return self.name
    def _lines(self):
        return SavedFeeComparisonLine.objects.filter(parent=self)
    lines = property(_lines)

    def details_as_text(self):
        details = ''
        #if len(set([l.framework_panel for l in self.lines]))==1:
        #    details+='Framework Panel: %s\n'%self.lines[0].framework_panel
        #else: details+='Multiple Framework Panels\n'
        c=0
        for l in self.lines:
            c+=1
            details += 'line %s: %s, %s, %s, %s, times %s\n'%(c,l.framework_panel,l.level_of_court,l.type_of_work,l.seniority,l.quantity)
        return details


class SavedFeeComparisonLine(FeeParametersNoChamber):
    """ class for line items.
     includes standard fee parameters - fpanel, level of court etc.."""
    #---additional fields---
    quantity = models.IntegerField()
    parent = models.ForeignKey(SavedFeeComparison)
    chambers = models.ManyToManyField(Chamber, blank=True, editable=False)


class SavedFeeCalculation(models.Model):
    name = models.CharField(max_length=500)
    author = models.ForeignKey(User)
    visible = models.BooleanField()
    fee_comparison = models.ForeignKey(SavedFeeComparison, blank=True, null=True, editable=False) # optional parent fee comp.
    #lines = models.ManyToManyField(SavedFeeCalculatorLine, blank=True, editable=False)
    chamber = MyForeignKey(Chamber, blank=True, editable=False) #optional - may not be a single chamber
    #allowed_groups = models.ManyToManyField(Group, blank=True, null=True)
    #similar to comparison, but this one names specific chambers, therefore has 1 total
    disbursements = models.FloatField(default=0, blank=True, null=True)#blank allows null values = "n/a" in current spreadsheet
    overall_total = models.FloatField(blank=True, null=True)#blank allows null values = "n/a" in current spreadsheet

    class Meta(Parameter.Meta):
        ordering = ['overall_total']

    def __unicode__(self):
        try:
            return '%s (total: %.2d)' % (self.name, self.overall_total)
        except:
            return '%s (total unknown)' % self.name

    def save(self, *args, **kwargs):
        """
        attempts to populate overall_total by looking for child lines.
        adds disbursements.
        """
        if not self.overall_total:
            lines = SavedFeeCalculatorLine.objects.filter(parent=self)
            total = sum([line.line_total for line in lines])
            total += self.disbursements and self.disbursements or 0
            self.overall_total = total
        super(SavedFeeCalculation, self).save(*args, **kwargs)


class SavedFeeCalculatorLine(models.Model):
    fee = models.ForeignKey(Fee)
    quantity = models.FloatField()
    line_total = models.FloatField(blank=True, null=True, editable=False)#blank allows null values = "n/a" in current spreadsheet
    parent = models.ForeignKey(SavedFeeCalculation)

    def save(self, *args, **kwargs):
        try:
            total = float(self.fee.fee) * float(self.quantity)
        except:
            total = 0
        self.line_total = total
        #and call super save.
        super(SavedFeeCalculatorLine, self).save(*args, **kwargs)



#==========================================================================
# Fee Structures (entering fee info) 
#==========================================================================


class FeeStructure(models.Model):
    name = models.TextField()
    chamber = models.ForeignKey(Chamber)


    def __unicode__(self):
        return self.name


    @property
    def assignments(self):
        return self.feestructureassignment_set.all()


    @property
    def average_fee(self):
        averages_dict = {}
        for fee_type in FeeType.objects.all():
            fees = [sf.fee for sf in self.structuredfee_set.all() if sf.fee_type==fee_type]
            if fees:
                averages_dict[fee_type] = sum(fees) / len(fees)
        return averages_dict


    def panels_as_list(self):
        output = ''
        for panel in Panel.objects.all():
            assignments = self.assignments.filter(panel=panel)
            if assignments:
                output += '%s: ' % (panel, )
                assignment_courts = [a.level_of_court for a in assignments if a.level_of_court]
                panel_courts = panel.court_set.all()
                if set(assignment_courts) == set(panel_courts):
                    output += 'All.<br />'
                else:
                    output += 'Partial.<br />'
        return output



class StructuredFee(models.Model):
    fee_structure = models.ForeignKey(FeeStructure)

    fee_type = MyForeignKey(FeeType)
    type_of_work = MyForeignKey(WorkType)
    seniority = MyForeignKey(Seniority)

    fee = models.FloatField(blank=True, null=True)

    class Meta:
        unique_together = ('fee_structure','fee_type','type_of_work','seniority')


class FeeStructureAssignment(models.Model):
    fee_structure = models.ForeignKey(FeeStructure)
    panel = models.ForeignKey(Panel)
    level_of_court = models.ForeignKey(Court, blank=True, null=True)

    class Meta:
        unique_together = ('fee_structure','panel','level_of_court')

    def __unicode__(self):
        return '%s assigned to %s / %s' % (self.fee_structure.name, self.panel, self.level_of_court)


    def convert_to_fees(self):
        if not self.level_of_court:
            if self.fee_structure.chamber.professional_type.id!=SOLICITORS:
                return

        for structured_fee in self.fee_structure.structuredfee_set.all():
            if structured_fee.fee:
                fee, _ = Fee.objects.get_or_create(
                    chamber=self.fee_structure.chamber,
                    professional_type=self.fee_structure.chamber.professional_type,

                    framework_panel=self.panel,
                    level_of_court=self.level_of_court,

                    fee_type=structured_fee.fee_type,
                    seniority=structured_fee.seniority,
                    type_of_work=structured_fee.type_of_work,
                )
                fee.fee=structured_fee.fee
                fee.save()


#==========================================================================
# Method Statements
#==========================================================================

#method statements currently map to fee calculations, altho this isn't really necessary...
#does permit to check that quoted total = theoretical total


#method statement template, contains description, which framework panel it's for
class MethodStatementTemplate(models.Model):
    id = models.AutoField(primary_key=True)
    framework_panel = MyForeignKey(Panel)
    name = models.CharField(max_length=500)
    description = models.TextField(blank=True)


#several stages for each template
class MethodStatementTemplateStage(models.Model):
    id = models.AutoField(primary_key=True)
    parent = models.ForeignKey(MethodStatementTemplate)
    number = models.IntegerField()
    name = models.CharField(max_length=900)


#actual chamber's method statement response for a panel/template
class MethodStatement(models.Model):
    template = models.ForeignKey(MethodStatementTemplate)
    #chamber = MyForeignKey(Chamber)
    quoted_total = models.FloatField(blank=True, null=True)
    fee_calculation = models.ForeignKey(SavedFeeCalculation,blank=True, null=True)
    score = models.FloatField(blank=True, null=True, default=0)


#child stage
class MethodStatementStage(models.Model):
    parent = models.ForeignKey(MethodStatement)
    stage = models.ForeignKey(MethodStatementTemplateStage)
    quoted_subtotal = models.FloatField(blank=True, null=True)


#child line item
class MethodStatementLine(models.Model):
    stage = models.ForeignKey(MethodStatementStage)
    feecalc_line = models.ForeignKey(SavedFeeCalculatorLine,blank=True, null=True)
    quoted_rate = models.FloatField(blank=True, null=True)
    quoted_fee = models.FloatField(blank=True, null=True)
    disbursements = models.FloatField(blank=True, null=True, default=0)
    comments = models.TextField(blank=True)
    #TODO: got circular relationship here... 
    # line.fc_line.parent = line.stage.parent.fee_calculation
    # not ideal database best practice, but minimal impact


#===========================================================================
#--------COMMISSIONING 
#===========================================================================
'''
ESTIMATE_STATUS = (
        #represents the workflow of an estimate/request/response
        ('Pending','Pending'), #being drafted, not yet sent to chambers/firms
        ('Requested','Requested'), #sent to chambers/firms
        ('Declined', 'Declined'), #declined/ignored by firms
        ('Responded', 'Responded'), #firms have responded, added any additional info
        ('Approved', 'Approved'), #1 firm is awarded the work
        ('Rejected', 'Rejected'), # the others are rejected
)



class WorkCommission(models.Model):
    """
    A WorkCommission is drafted by a Local Authority,
    it describes a piece of legal work
    this may then be associated with several estimate requests
    which are sent to firms/chambers

    states are:
    ==> ('1','Created','1'),
        ('2','Requested','1'),
         ('3','Estimated','1'),
         ('4','Accepted','1'),
         ('5','Concluded','1'),
         ('6','Cancelled','1');

    """
    la_ref = models.CharField(_('Reference'), max_length=60, unique=True)
    la = models.ForeignKey(Organisation)
    contact = models.ForeignKey(User, related_name='contact')
    instruction = models.TextField(_('Summary of Instruction'), blank=True, null=True)
    total_cost = models.FloatField(_('Total Cost'),default=0)
    attachment1 = models.FileField(upload_to="uploads/instructions/%Y/%m", blank=True, null=True)
    attachment2 = models.FileField(upload_to="uploads/instructions/%Y/%m", blank=True, null=True)
    attachment3 = models.FileField(upload_to="uploads/instructions/%Y/%m", blank=True, null=True)
    attachment4 = models.FileField(upload_to="uploads/instructions/%Y/%m", blank=True, null=True)
    attachment5 = models.FileField(upload_to="uploads/instructions/%Y/%m", blank=True, null=True)
    created = models.DateTimeField(_('Created Date'), auto_now_add=True, editable=False)
    close_date = models.DateTimeField(_('Submit Estimate By'), default=datetime.now, blank=True, null=True)
    
    fee_comparison = models.ForeignKey(SavedFeeComparison, blank=True, null=True)

    def __unicode__(self):
        return self.la_ref

    def attachname1(self):
        return self.attachment1.name.split("/")[-1]
    def attachname2(self):
        return self.attachment2.name.split("/")[-1]
    def attachname3(self):
        return self.attachment3.name.split("/")[-1]
    def attachname4(self):
        return self.attachment4.name.split("/")[-1]
    def attachname5(self):
        return self.attachment5.name.split("/")[-1]
        
    class Meta:
        ordering = ['la', 'created']
    
    def _estimates(self):
        return Estimate.objects.filter(commission=self)
    estimates = property(_estimates)


ESTIMATE_FEE_TYPE = (
    ('Variable','Variable'),
    ('Fixed','Fixed'),
    ('Capped','Capped'),
 )
 
class Estimate(models.Model):
    """
    Estimates requested/submitted for a WorkCommission
    move thru a workflow: initially request by an LA,
    then either 'responded' or 'declined' by an legal org,
    then 1 is approved and others rejected... 
    """
    commission = models.ForeignKey(WorkCommission, editable=False)
    legal = models.ForeignKey(Chamber)

    #status describes where we are in the workflow
    status = models.CharField(_('Estimate Status'), max_length=9, choices=ESTIMATE_STATUS, default="Pending")
    
    fee_type = models.CharField(_('Fee Type'), max_length=10, choices = ESTIMATE_FEE_TYPE, default='Variable')
    
    quantity = models.PositiveIntegerField(_("Number of hours"), max_length=6, default=0)
    #fee_calculation = models.ForeignKey(SavedFeeCalculation, blank=True)
    
    #fields to be populated by legal orgs in responding:
    #conditions = models.TextField(_("Special Terms"), null=True, blank=True)
    fee_estimate = models.TextField(_("Fee Estimate"), null=True, blank=True)
    notes = models.TextField(_("Notes"), null=True, blank=True)
    total = models.FloatField(_('Total Hours'),blank=True,null=True)
    total_cost = models.FloatField(_('Total Cost'),default=0)
    attachment = models.FileField(upload_to="uploads/estimates/%Y/%m", blank=True, null=True)

    submitted_by = models.ForeignKey(User, editable=False, blank=True, null=True)
    submitted_date = models.DateTimeField(_('Date Submitted'), null=True, blank=True, editable=False)

    def __unicode__(self):
        return "%d/%d" % (self.commission.id, self.id)

    def attachname(self):
        return self.attachment.name.split("/")[-1]

    class Meta:
        ordering = ['-commission', 'id']
    
    def respond(self, user):
        # ! check all details been included
        self.status="Responded"
        self.submitted_by=user
        self.submitted_date=datetime.now()
        self.save()

    def decline(self, user):
        self.status="Declined"
        self.submitted_by=user
        self.submitted_date=datetime.now()
        self.save()

    def approve(self):
        """
        accept the current estimate and decline all other estimates for this commission
        """

        self.status="Approved"
        self.save()

        others = Estimate.objects.filter(commission=self.commission, status="Responded")
        for o in others:
            o.status="Rejected"
            o.save()
            

'''
